# 看代码说结果

## Problem 1

```js
var foo = 1;
(function foo(){
    foo = 100;
    console.log(foo);
}())
console.log(foo);
```

原题链接: [理解一道js面试题](https://juejin.im/post/5cb75f56f265da03b11f2fe7?utm_source=gold_browser_extension)

## 连续赋值有关

```js
var a = {n: 1};
var b = a;
a.x = a = {n: 2};
console.log(a.x);
console.log(b);
```

关键点一：a.x即完成了x的声明，其值为undefined(.运算符 优先级高于 赋值运算符)
关键点二：对象成员等待赋值时，锁定的赋值目标是成员，而非对象。
关键点三：对象重新赋值时，并非是修改原堆内存的值，而是重新分配堆内存，栈内存中的指针会做相应修改。（如果原堆内存有多个栈内存指向它，由于引用还存在，原堆内存的数据不会消失。如果堆内存再无其它引用，则会被JS的垃圾回收机制回收。对象的成员对象也一样。PS：引用类型应该都如此）


相关链接: 
+ [知乎](https://www.zhihu.com/question/41220520)
+ [github]()


## 考察隐式类型转换

下述代码在什么时候会输出 1

```js
var a = ?;
if(a == 1 && a == 2 && a == 3){
 	conso.log(1);
}
```

== 进行隐式类型转换

var a = {
    i: 1,
    toString(){
        return i++;
    }
}

