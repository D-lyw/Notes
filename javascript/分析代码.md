# 分析代码

## Problem 1

```js
var foo = 1;
(function foo(){
    foo = 100;
    console.log(foo);
}())
console.log(foo);
```

原题链接: [理解一道js面试题](https://juejin.im/post/5cb75f56f265da03b11f2fe7?utm_source=gold_browser_extension)



## 连续赋值有关

```js
var a = {n: 1};
var b = a;
a.x = a = {n: 2};
console.log(a.x);
console.log(b);
```

关键点一：a.x即完成了x的声明，其值为undefined(.运算符 优先级高于 赋值运算符)
关键点二：对象成员等待赋值时，锁定的赋值目标是成员，而非对象。
关键点三：对象重新赋值时，并非是修改原堆内存的值，而是重新分配堆内存，栈内存中的指针会做相应修改。（如果原堆内存有多个栈内存指向它，由于引用还存在，原堆内存的数据不会消失。如果堆内存再无其它引用，则会被JS的垃圾回收机制回收。对象的成员对象也一样。PS：引用类型应该都如此）


相关链接: 
+ [知乎](https://www.zhihu.com/question/41220520)
+ [github]()



## 考察隐式类型转换

下述代码在什么时候会输出 1

```js
var a = ?;
if(a == 1 && a == 2 && a == 3){
 	conso.log(1);
}
```

== 进行隐式类型转换

var a = {
    i: 1,
    toString(){
        return i++;
    }
}



## 神奇的输出

```JavaScript
> ('b' + 'a' + + 'a' + 'a').toLowerCase()
< "banana"
```

`n`是从哪来的呀？





## 分析代码执行结果

```JavaScript
function wait() {
  return new Promise(resolve =>
  	setTimeout(resolve, 10 * 1000)
  )
}

async function main() {
  console.time();
  const x = wait();
  const y = wait();
  const z = wait();
  await x;
  await y;
  await z;
  console.timeEnd();
}
main();
```

**分析**：

考察*先执行再等待*和*直接执行并等待*的区别



## Javascript 综合考察

```javascript
function Foo() {
    getName = function () { alert (1); };
    return this;
}
Foo.getName = function () { alert (2);};
Foo.prototype.getName = function () { alert (3);};
var getName = function () { alert (4);};
function getName() { alert (5);}
 
//请写出以下输出结果：
Foo.getName();				// 静态方法 3
getName();					// 
Foo().getName();
getName();
new Foo.getName();
new Foo().getName();
new new Foo().getName();
```



## Javascript 在函数中形参和局部变量同名问题

##### 变量的定义、赋值和重复定义

```JavaScript
let a = 1
let a 
console.log(a)		// 1
```



```javascript
var foo={n:1};

(function (foo) {
    console.log(foo.n);
    foo.n = 3;
    var foo = {n:2};
    console.log(foo.n);
})(foo);

console.log(foo.n);
```



About links: https://www.jianshu.com/p/7d384261ee75



